![](images/Eureka_Software_Architecture_Component_Diagram.jpg)

## [Action framework][]

This design describes the Action Framework within Eureka Streams. The Action Framework is the logical layer that contains the business logic for the system. This layer also controls the transactions to ensure ACID access to the underlying data within Eureka. Currently this design is broken into two parts, the Service and Async sides.

## [Notification framework][]

Notifications are sent by calling an async action whenever an "event" occurs, typically done inside another action such as PostActivityComment. A single system event may require multiple notifications to be sent, and the flavors required may depend on rules or dynamic runtime conditions. (For example, commenting on an activity sends different notifications to the stream owner, the author of the activity, and any other people who commented, but should not notify the person making the comment.) To handle this, Translators are defined for each event type and are responsible for generating the appropriate list of notifications for that particular event. These are wired up by Spring. These translators choose from the enumeration NotificationType when determining which notifications to generate. Notifications themselves are transport- and medium-agnostic – they only contain the data itself. Notifiers are responsible for sending a notification on a specific medium, such as email. One or more Notifiers are defined in a Spring configuration file and are responsible for sending notifications for each NotificationType that a Translator returns.

## [OpenSocial framework][]

The OpenSocial Framework within Eureka Streams covers two particular aspects, access to the OpenSocial API as well as the OpenSocial Gadget Container. The implementation of the OpenSocial specification is covered with the open source Apache Shindig project in Java. Eureka Streams integrates with Shindig in 2 different places: JavaScript container file, and Java interface implementations. These two integration points enable Eureka Streams to be an OpenSocial 0.9 Container.

## [Persistence framework][]

The Persistence Framework provides controlled access to the underlying storage mechanisms within Eureka Streams. These storage mechanisms include DB storage, Cache, and Search.

## [Resource framework][]

Eureka Streams exposes certain information through REST Resources. The REST resources support gadgets as well as the UI when calls cannot be made through GWT's RPC mechanism. Eureka Streams uses the RESTlet framework for creating REST resources. RESTlet provides a way to wire up implementations for REST endpoints within Spring along with configuration of the resource url's.

## [Stream plugin framework][]

When a user subscribes to an internet feed such as flickr, google news reader, YouTube, del.icio.us, or twitter, Eureka polls these feeds for content and inserts this content into their Activity Feed.

## [Task framework][]

The Task Framework contains the mechanisms that allow an Action to submit a request for another Action to be executed in a separate thread. This allows Eureka to offload heavy load processes to a separate server where the load can be distributed and removed from the web servers that are responding to user requests.

## [User interface framework][]

The design of the front end is simple, modular and loosely coupled. There are two layers that exist in the front end, connected by the Event Bus. The top layer that communicates directly with the server are the Client Models that communicate through the Action Processor. The bottom layer is the collection of views that draw the screen. Each view requests data directly from a Client Model, and is notified via the Event Bus when the data has been returned. With that data the view then renders the screen through the use of GWT widgets. All views extend an already existing GWT widget. There is a master view that is the top level view for all others. It contains a content view, as well as views for the header and footer. The content view is changed when the URL is updated via History Management, also through the Event Bus. This design follows the MVP pattern, with the Event Bus representing a common and generic Controller.